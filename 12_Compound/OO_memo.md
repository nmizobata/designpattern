# Object Oriented Design
## OOの基礎
- 抽象化・カプセル化(ブラックボックス化)・多態性・継承
## OOの原則
- 変化する部分をカプセル化する。
- 継承よりコンポジションの方が好ましい。
  - 継承では、その振る舞いはコンパイル時に静的に設定される。またすべてのサブクラスが同じ振る舞いを継承しなければならない。
  - コンポジションで振る舞いを定義し、オプジェクトがコンポジションに振る舞いを委譲するように設計すると、振る舞いの定義を実行時に動的に行うことができる。
- オブジェクトは、実装(サブクラス)に対してではなくインターフェースに対してプログラミングする。
  - サブクラスは既存コードを変更するのではなく新しいコードを書くことで自由に追加できる。(Open-Closedの原則を参照)
  - オブジェクトは自らを変更することなく、任意のサブクラスでも正しく動作する。(多態性)
- 相互にやり取りするオブジェクト間には、疎結合設計を使用する。
- クラスを拡張に対しては開かれた状態にするべきだが、変更に対しては閉じた状態にする。(Open-Closedの原則)
  - Open-Closedの原則に従う場合、抽象化が必要であるため、コードが複雑になる(具体的な動きが掴みにくくなる)デメリットがある。そのためすべてに適用する必要はない。変化する可能性がもっとも高い部分にのみ適用すべきである。
- 抽象(高水準コンポーネント)に依存する。具象クラスに依存していはいけない。(依存関係反転の原則)
  - 高水準コンポーネントとは、低水準に比べて、より一貫性のある定義された振る舞いを持つクラスのこと。
  - 利用者は低水準のクラス群を直接利用するのではなく、間に抽象クラスを挟んで利用すること。
- 直接の友達とだけやり取りする。(最小知識の原則)
  - オブジェクトのメソッドを呼び出すときは、1.オブジェクト自身のメソッド、2.メソッドの引数として渡されたオブジェクトのメソッド、3.メソッドが作成またはインスタンス化するオブジェクトのメソッド、4.そのオブジェクトのコンポーネントのメソッド、に限定する。
- 低水準のコンポーネントから高水準のコンポーネントを呼び出さない。(ハリウッドの原則)
- 1つのクラスに1つの責務だけ割り当てるようにする (単一責務の原則)
## OOパターン
- Strategy: 一連のアルゴリズムを定義してカプセル化し、交換できるようにする。Strategyパターンを使うと、アルゴリズムを利用するクライアントとは独立してアルゴリズムを変更できる。
- Observer: オブジェクト間の1対多の依存関係を定義し、あるオブジェクトの状態が変化すると、そのオブジェクトに依存しているすべてのオブジェクトに自動的に通知され更新されるようにする。
- Decorator: オブジェクトに追加の責務を動的に付与する。Decoratorはサブクラス化の代替となる、柔軟な機能拡張手段を備えている。
- Factory Method: オブジェクトを作成するためのインターフェースを定義するが、どのクラスをインスタンス化するかについてはサブクラスに決定させる。Factory Methodにより、クラスはサブクラスにインスタンス化を委ねることができる。
- Abstract Factory: クライアントが具象クラスを指定することなしに、一連の関連オブジェクトや依存オブジェクトを作成するためのインターフェースを提供する。Factory Methodは継承を使ってサブクラスにオブジェクト作成を委ね、Abstract Factoryはオブジェクトコンポジションを使って一連の関連オブジェクト群を作成することで、具象クラスへの依存度を減らす疎結合を実現する。
- Sigleton: クラスがインスタンスを一つしか持たないことを保証し、そのインスタンスにアクセスするグローバルポイントを提供する。
- Command: リクエストをオブジェクトとしてカプセル化し、その結果、他のオブジェクトを様々なリクエスト、キュー、またはログリクエストまでパラメータ化でき、アンドゥ可能な操作もサポートする。
- Adapter: クラスのインターフェースを、クライアントが要求する別のインターフェースに変換する。アダプタは、インタフェースの互換製がないためにそのままでは連携できないクラスを連携させる。
- Facade: サブシステムの一連のインターフェースに対する、統合されたインターフェースを提供する。ファサードはサブシステムをより使いやすくする高水準インターフェースを定義する。
- Template Method: メソッド内でアルゴリズムの骨組みを定義し、一部の手順をサブクラスに委ねる。Template Methodはアルゴリズムの構造を変えることなく、アルゴリズムのある手順をサブクラスに定義させる。
- Iterator: 内部表現を公開せずに、アグリゲートオブジェクトの要素に順次アクセスする方法を提供する。
- Composite: オブジェクトをツリー構造に構成して部分～全体階層を表現できる。Compositeパターンを使うと、クライアントは個々のオブジェクトとオブジェクトのコンポジションを統一的に扱うことができる。
- State: オブジェクトの内部状態が変化した際にオブジェクトが振る舞いを変更できる。オブジェクトはそのクラスを変更したように見える。
- Proxy: 別のオブジェクトの代理(プレースホルダー)を提供し、そのオブジェクトへのアクセスを制御する。
- Compoundパターン: 2つ以上のパターンを組み合わせ、l繰り返し発生する問題や一般的な問題を解決する解決策となる。