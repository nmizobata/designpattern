# Object Oriented Design
## 設計の方針
- KISS(Keep It Simple, Stupid)。パターンを適用するのが目的ではなく、シンプルがもっとも重要。
- しかし、将来にわたって(変更に対応しなければならない時)も考慮すると、パターンを導入したほうがシンプルになる場合もある。
- デザインパターンの使い過ぎは、過剰設計となる恐れがある。
## OOの基礎
- 抽象化・カプセル化(ブラックボックス化)・多態性・継承
## OOの原則
- 変化する部分をカプセル化する。
- 継承よりコンポジションの方が好ましい。
  - 継承では、その振る舞いはコンパイル時に静的に設定される。またすべてのサブクラスが同じ振る舞いを継承しなければならない。
  - コンポジションで振る舞いを定義し、オプジェクトがコンポジションに振る舞いを委譲するように設計すると、振る舞いの定義を実行時に動的に行うことができる。
- オブジェクトは、実装(サブクラス)に対してではなくインターフェースに対してプログラミングする。
  - サブクラスは既存コードを変更するのではなく新しいコードを書くことで自由に追加できる。(Open-Closedの原則を参照)
  - オブジェクトは自らを変更することなく、任意のサブクラスでも正しく動作する。(多態性)
- 相互にやり取りするオブジェクト間には、疎結合設計を使用する。
- クラスを拡張に対しては開かれた状態にするべきだが、変更に対しては閉じた状態にする。(Open-Closedの原則)
  - Open-Closedの原則に従う場合、抽象化が必要であるため、コードが複雑になる(具体的な動きが掴みにくくなる)デメリットがある。そのためすべてに適用する必要はない。変化する可能性がもっとも高い部分にのみ適用すべきである。
- 抽象(高水準コンポーネント)に依存する。具象クラスに依存していはいけない。(依存関係反転の原則)
  - 高水準コンポーネントとは、低水準に比べて、より一貫性のある定義された振る舞いを持つクラスのこと。
  - 利用者は低水準のクラス群を直接利用するのではなく、間に抽象クラスを挟んで利用すること。
- 直接の友達とだけやり取りする。(最小知識の原則)
  - オブジェクトのメソッドを呼び出すときは、1.オブジェクト自身のメソッド、2.メソッドの引数として渡されたオブジェクトのメソッド、3.メソッドが作成またはインスタンス化するオブジェクトのメソッド、4.そのオブジェクトのコンポーネントのメソッド、に限定する。
- 低水準のコンポーネントから高水準のコンポーネントを呼び出さない。(ハリウッドの原則)
- 1つのクラスに1つの責務だけ割り当てるようにする (単一責務の原則)
## OOパターン
- パターンとは「制約や目的がある問題を抱えているコンテキストに遭遇するたびに、その目的や制約を解決し解決策に導く設計を適用できるもの」である。
- Strategy: 一連のアルゴリズムを定義してカプセル化し、交換できるようにする。Strategyパターンを使うと、アルゴリズムを利用するクライアントとは独立してアルゴリズムを変更できる。
- Observer: オブジェクト間の1対多の依存関係を定義し、あるオブジェクトの状態が変化すると、そのオブジェクトに依存しているすべてのオブジェクトに自動的に通知され更新されるようにする。
- Decorator: オブジェクトに追加の責務を動的に付与する。Decoratorはサブクラス化の代替となる、柔軟な機能拡張手段を備えている。
- Factory Method: オブジェクトを作成するためのインターフェースを定義するが、どのクラスをインスタンス化するかについてはサブクラスに決定させる。Factory Methodにより、クラスはサブクラスにインスタンス化を委ねることができる。
- Abstract Factory: クライアントが具象クラスを指定することなしに、一連の関連オブジェクトや依存オブジェクトを作成するためのインターフェースを提供する。Factory Methodは継承を使ってサブクラスにオブジェクト作成を委ね、Abstract Factoryはオブジェクトコンポジションを使って一連の関連オブジェクト群を作成することで、具象クラスへの依存度を減らす疎結合を実現する。
- Sigleton: クラスがインスタンスを一つしか持たないことを保証し、そのインスタンスにアクセスするグローバルポイントを提供する。
- Command: リクエストをオブジェクトとしてカプセル化し、その結果、他のオブジェクトを様々なリクエスト、キュー、またはログリクエストまでパラメータ化でき、アンドゥ可能な操作もサポートする。
- Adapter: クラスのインターフェースを、クライアントが要求する別のインターフェースに変換する。アダプタは、インタフェースの互換製がないためにそのままでは連携できないクラスを連携させる。
- Facade: サブシステムの一連のインターフェースに対する、統合されたインターフェースを提供する。ファサードはサブシステムをより使いやすくする高水準インターフェースを定義する。
- Template Method: メソッド内でアルゴリズムの骨組みを定義し、一部の手順をサブクラスに委ねる。Template Methodはアルゴリズムの構造を変えることなく、アルゴリズムのある手順をサブクラスに定義させる。
- Iterator: 内部表現を公開せずに、アグリゲートオブジェクトの要素に順次アクセスする方法を提供する。
- Composite: オブジェクトをツリー構造に構成して部分～全体階層を表現できる。Compositeパターンを使うと、クライアントは個々のオブジェクトとオブジェクトのコンポジションを統一的に扱うことができる。
- State: オブジェクトの内部状態が変化した際にオブジェクトが振る舞いを変更できる。オブジェクトはそのクラスを変更したように見える。
- Proxy: 別のオブジェクトの代理(プレースホルダー)を提供し、そのオブジェクトへのアクセスを制御する。
- Compoundパターン: 2つ以上のパターンを組み合わせ、l繰り返し発生する問題や一般的な問題を解決する解決策となる。
## その他のOOパターン
- Bridge: 実装と抽象を別々のクラス改装に置くことにより、実装と抽象の両方を変えられるようにする。
  - 実装を分離しているので、一つのインターフェースに永久に結び付けられない。
  - 抽象と実装を独立して拡張できる。
  - 抽象の具象クラスへの変更がクライアントに影響を与えない。
  - 複数プラットフォーム上で稼働する必要のあるシステムで役立つ。
- Builder: 製品の構築をカプセル化。複数手順の様々なプロセスでオプジェクトを構築できる。クライアントからは抽象インターフェースしか見えず、製品の実装方法を交換できる。
- Chain of Responsibility: 要求を調べるオブジェクトのチェーンを作成し、要求が与えられたら処理を行うか、次の処理に引き渡していく。
  - オブジェクトはチェーンの構造を知る必要はなく、チェーンのメンバーを参照する必要もない。
  - チェーンのメンバーや順序を変えれば、責務を動的に追加削除できる。
- Flyweight: 一つのインスタンスを使って、多数の仮想インスタンスを作る。インスタンスを複数作るよりも処理が軽くなる。
- Interpreter: シンプルな言語を実装する必要がある場合に使う。文法のクラスベースの表現と分を解釈するインタープリタを定義。
  - 言語の実装が容易になる。
  - クラスで表現するため、言語の変更や拡張が容易になる。
  - メソッドを加えることで、新機能を追加できる。
- Mediator: オブジェクト間の間に入り、関連するオブジェクト間の複雑なやり取りと制御を仲介・集中化。
  - Mediatorによりオブジェクト同士を分離することができる。
  - 制御ロジックをMediatorに集中化することができる。
- Memento: アンドゥ機能を実現するパターン
  - 保存状態を主要オブジェクトの外部に置く。
  - 実装が簡単な復旧機能を提供する。
- Prototype: インスタンス作成にコストや複雑さがあるとき、既存のインスタンスをコピーして新しいインスタンスを作るPrototypeを使う。
- Visitor: コンポジットに機能を加えたいが、コンポジットには変更を加えたくないとき。Traverserに導いてもらい、コンポジット内の状態を収集したり、アクションを行わせる。
  - コンポジット構造自体を変更せずにコンポジット構造に操作を追加できる。
  - 新たな操作の追加が比較的容易。
  - Visitoerが実行する操作のコードを集中化する。
## パターンの構成
- 名前: 他の開発者と共有できるボキャブラリになる
- 分類: カテゴリ
- 意図: パターンが何をするかに関する短い説明。パターンの定義。
- 動機: 問題とその問題の解決策について書いた具体的なシナリオ
- 適用可能性: パターンを適用できる状況
- 構造: パターンに参加するクラス間の関係を表す図
- 参加者: 設計内のクラスとオブジェクトのこと。このセクションでパターン内でのクラスやオブジェクトの責務と役割を解説
- 協調: 参加者がどのようにしてパターンの中で連携しているか。
- 結果: このパターンを使用した際の影響(よい影響、わるい影響)について説明
- 実装: このパターンを実装する場合に必要なテクニックと注意すべき問題点を記載。
- サンプルコード: 実装のサンプル
- 使用例: このパターンが実システムで使用された例
- 関連パターン: 他のパターンとの関係