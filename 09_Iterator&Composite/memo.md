# Iteratorパターン
## 各Phaseの内容
- phase1: コレクションフォーマットが異なるが無理やりつなげたコード
- phase2: Iteratorパターンを導入したコード
- phase3: PythonのIterator機能を導入したコード
- phase4: Conpositeパターンを導入したコード
## 用語
- アグリゲートオブジェクト: データのコレクション(集まり)を提供するオブジェクト
- 外部イテレータ/内部イテレータ: 外部イテレータは、クライアント(イテレータの外部)がNext()を呼び出して次のアイテムを得るイテレータ。内部イテレータはそれをイテレータ自身が行うもの。
- コレクション型: List型、Dict型、タプル型、Set型等、データの集まりをひとまとめにしている型。それぞれに、コレクション型特有のメソッド(追加、取り出し、削除、含むかチェック、等)を持つ。
- イテレータ: コレクションの要素を順に取り出す機能を持つオブジェクト。要素を取り出すnext()メソッドを持ち、一度取り出したデータは二度と取り出せない性格を持つ。
- イテラブルオブジェクト: 要素を順次取り出す機能を持つオブジェクト。ただしイテレータではないのでnext()は使えない。(next()に似たような機能としてlist.pop()がある)
- 
## 概要
- データのコレクションの作り方は、リストや配列など、様々な型がある。しかしデータをすべて一括して走査(順に取り出す)するときにコレクションごとの表現方法を知り区別して実装しなければならない。コレクションの型を作り変えるのは現実的ではない。
- そこで、クライアントとアグリゲートオブジェクトの間にIteratorオブジェクトを用意し、クライアントは各アグリゲートオブジェクトの差異をIteratorオブジェクトで吸収、クライアントに対し共通のメソッドを提供することで、アグリゲートオブジェクトのデータ内部構造をカプセル化して要素の走査をできるようにする。
## 手段
- Iteratorオブジェクトは、Iteratorインターフェースを継承しhasNext()とnext()メソッドを実装する。アグリゲートオブジェクトは、データ走査に関する一連の実装は不要になり、データの管理(1件1件のデータの追加削除等)のみの責務に集中させる。
- Iteratorにデータの順序の概念はなく、一つ一つをすべて取り出す、と理解しておく。
- Python Classの特殊メソッド __iter__と__next__でイテレータを作成することができる。なお、__next__を持つクラスはイテレータとなる(__next__で取り出された要素は戻らない)

## その他の知識
- 関数の引数が複数ある時に、それをリストやタプルで渡すとき、リストやタプルは*を付けて渡す。
- キーに引数のキーを、値に引数の値を付けて作成した辞書型変数は、**を付けて渡すと展開される。

# Conpositeパターン
## 用語
- コンポジション: ツリー全体
- コンポーネント: コンポジション内のすべての要素一つ一つ
- リーフ: 子を持たないコンポーネント
- コンポジット: 子を持つコンポーネント
## 概要
- Iteratorパターンが1階層1組のデータコレクションであるのに対し、Compositeパターンはツリー構造で構成される複数階層のデータコレクションを扱う。
- オプジェクトのコンポジションと個々のオブジェクトの両方をノードとして含むツリー形式でオブジェクトの構造を構築できる。
- コンポジット構造を使うと、コンポジットと個々のオブジェクトの両方に対して同じ操作を適用できる。言い換えれば、ほとんどの場合、オブジェクトのコンポジションと個々のオブジェクトとの違いを無視できる。
- 個々のオブジェクトは単なるメニュー項目で、他のオブジェクトは持たない。
- コンポーネントは、リーフ、コンポジットの区別なく、同じメソッドを持つ。(したがって、意味のないメソッドも存在する)

## 特徴
- 全体に対する指示: 最上位のコンポーネントに対し指示する。