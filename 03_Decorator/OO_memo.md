# Object Oriented Design
## OOの基礎
- 抽象化・カプセル化(ブラックボックス化)・多態性・継承
## OOの原則
- 変化する部分をカプセル化する。
- 継承よりコンポジションの方が好ましい。
  - 継承では、その振る舞いはコンパイル時に静的に設定される。またすべてのサブクラスが同じ振る舞いを継承しなければならない。
  - コンポジションで振る舞いを定義し、オプジェクトがコンポジションに振る舞いを委譲するように設計すると、振る舞いの定義を実行時に動的に行うことができる。
- オブジェクトは、実装(サブクラス)に対してではなくインターフェースに対してプログラミングする。
  - サブクラスは既存コードを変更するのではなく新しいコードを書くことで自由に追加できる。(Open-Closedの原則を参照)
  - オブジェクトは自らを変更することなく、任意のサブクラスでも正しく動作する。(多態性)
- 相互にやり取りするオブジェクト間には、疎結合設計を使用する。
- クラスを拡張に対しては開かれた状態にするべきだが、変更に対しては閉じた状態にする。(Open-Closedの原則)
  - Open-Closedの原則に従う場合、抽象化が必要であるため、コードが複雑になる(具体的な動きが掴みにくくなる)デメリットがある。そのためすべてに適用する必要はない。変化する可能性がもっとも高い部分にのみ適用すべきである。
- 抽象(高水準コンポーネント)に依存する。具象クラスに依存していはいけない。(依存関係反転の原則)
  - 高水準コンポーネントとは、低水準に比べて、より一貫性のある定義された振る舞いを持つクラスのこと。
  - 利用者は低水準のクラス群を直接利用するのではなく、間に抽象クラスを挟んで利用すること。
## OOパターン
- Strategy: 一連のアルゴリズムを定義してカプセル化し、交換できるようにする。Strategyパターンを使うと、アルゴリズムを利用するクライアントとは独立してアルゴリズムを変更できる。
- Observer: オブジェクト間の1対多の依存関係を定義し、あるオブジェクトの状態が変化すると、そのオブジェクトに依存しているすべてのオブジェクトに自動的に通知され更新されるようにする。
- Decorator: オブジェクトに追加の責務を動的に付与する。Decoratorはサブクラス化の代替となる、柔軟な機能拡張手段を備えている。
- Factory Method: オブジェクトを作成するためのインターフェースを定義するが、どのクラスをインスタンス化するかについてはサブクラスに決定させる。Factory Methodにより、クラスはサブクラスにインスタンス化を委ねることができる。
- Abstract Factory: クライアントが具象クラスを指定することなしに、一連の関連オブジェクトや依存オブジェクトを作成するためのインターフェースを提供する。Factory Methodは継承を使ってサブクラスにオブジェクト作成を委ね、Abstract Factoryはオブジェクトコンポジションを使って一連の関連オブジェクト群を作成することで、具象クラスへの依存度を減らす疎結合を実現する。