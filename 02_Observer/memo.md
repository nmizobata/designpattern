# Observerパターン
## 各phaseの説明
- phase1: Observerパターンを使わないコード。
- phase2: Observerパターンを使用したコード。
- phase3: 各Observerが必要とするデータのみ取得できるようにしたコード

## Observerパターンとは
- オブジェクトで何か発生したときに、オブジェクトにそれを知らせるパターン。
- 発行者(サービス提供者)はサブジェクト、利用者(サブスクライバ)はオブザーバ、と呼ばれる。
- オブザーバがサブジェクトを利用するのではなく、サブジェクトからオブザーバに通知することにより動作が簡潔になる。
- 個々のケースは、1サブジェクトｰ>多サブスクライバであるが、多サブジェクト->1サブスクライバというケースもある。(10_Compound phase5参照)

## 設計原則 - 疎結合
- 相互のやり取りを行うオブジェクトの間には疎結合設計を行う。
  - オブザーバはいつでも追加でき、オブザーバが追加されてもサブジェクトの変更の必要性はない。
  - オブザーバもサブジェクトも、登録/通知/削除の関係があるだけで、それ以外の依存関係はない。
  
## 要件
- WeatherDataクラスには「気温取得getTemperature()」「湿度取得getHumidity()」「気圧取得getPresure()」「何か発生したら起動measurementChanged()」の関数がある。
- measurementChanged()内に処理を実装する。
  - 気温、湿度、気圧の最新情報を取得。
  - 基本、湿度、気圧の情報を元に、「気象状況」「気象統計データ」「予想」を表示する。
    - 気象状況の表示: currentConditionDispplay.update(temp,humidity,pressure)
    - 気象統計データの表示: statisticDisplay.update(temp, humidity, pressure)
    - 予想の表示: forecastDisplay.update(temp, humidity, pressure)
  - 将来発生するかもしれない、別の表示ニーズに対し、measurementChanged()の中身を変えずに対応できる方法を考える。

## オブザーバの動作
- サブジェクトはデータを管理。サブジェクトのデータが変更されるとオブザーバに通知。
- オブザーバーは、サブジェクトに自分をサブスクライブ(登録)。登録したサブジェクトからのデータ更新情報を受信。不要になったらサブジェクトからアンサブスクライブ(脱退)を実行。
- Phase2
  - オブザーバからはサブジェクトに対して問い合わせは行わず、サブジェクトがオブザーバーに一方的に情報をプッシュする。
- Phase3
  - サブジェクトはトリガだけを行い(オブザーバーのupdateをコール)、オブザーバはサブジェクトのゲッター関数を使って必要な情報だけプルする。

## オブザーバパターンの定義
- サブジェクトのメソッド: オブザーバーの登録(オブザーバが利用)、オブザーバーの脱退(オブザーバが利用)、オブザーバへの通知(サブジェクトが利用)
- オブザーバのメソッド: アップデート(サブジェクトが利用)

## Phase1 - Observerパターンを利用しない実装
- 簡易的だが、displayデバイスが追加されると、WeaterDataクラスの変更を行わねばならない。

## Phase2,3 - Obaserverパターンを利用
- displayデバイスの登録/通知/削除のためSubjectクラスを設定し、Subjectの実装クラスとしてWeatherDataクラスを位置づける。
- displayデバイスクラスのインスタンス宣言時にWeatherDataクラスのインスタンスを紐づける。(WeatherDataに基づいて動作するdisplayデバイスクラス)

## その他
- クラス内で使用する変数は、コンストラクタ(__init__)で使用を開始する。
- クラス自らを引数として引き渡すときはfunc(self)のようにselfを使用する。
- クラスは複数のクラス(インターフェース)を親に持つことができる(多重継承)。
- なぜ継承よりもコンポジションが好ましいか。継承はプログラミング時に規定されてしまうが、コンポジションは実行時に構築できるように設計できるためである。